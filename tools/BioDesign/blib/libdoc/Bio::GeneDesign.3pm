.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::GeneDesign 3"
.TH Bio::GeneDesign 3 "2015-07-31" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::GeneDesign
.SH "VERSION"
.IX Header "VERSION"
Version 5.52
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SH "AUTHOR"
.IX Header "AUTHOR"
Sarah Richardson <smrichardson@lbl.gov>
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.SS "new"
.IX Subsection "new"
Returns an initialized Bio::GeneDesign object.
.PP
This function reads the ConfigData written at installation, imports the
relevant sublibraries, and sets the relevant paths.
.PP
.Vb 1
\&    my $GD = Bio::GeneDesign\->new();
.Ve
.SH "ACCESSORS"
.IX Header "ACCESSORS"
.SS "\s-1EMBOSS\s0"
.IX Subsection "EMBOSS"
returns a value if EMBOSS_support was vetted and approved during installation.
.SS "\s-1BLAST\s0"
.IX Subsection "BLAST"
returns a value if BLAST_support was vetted and approved during installation.
.SS "graph"
.IX Subsection "graph"
returns a value if graphing_support was vetted and approved during installation.
.SS "vmatch"
.IX Subsection "vmatch"
returns a value if vmatch_support was vetted and approved during installation.
.SS "enzyme_set"
.IX Subsection "enzyme_set"
Returns a hash reference where the keys are enzyme names and the values are
RestrictionEnzyme objects, if the enzyme
set has been defined.
.PP
To set this value, use set_restriction_enzymes.
.SS "enzyme_set_name"
.IX Subsection "enzyme_set_name"
Returns the name of the enzyme set in use, if there is one.
.PP
To set this value, use set_restriction_enzymes.
.SS "all_enzymes"
.IX Subsection "all_enzymes"
Returns a hash reference where the keys are enzyme names and the values are
RestrictionEnzyme objects
.PP
To set this value, use set_restriction_enzymes.
.SS "organism"
.IX Subsection "organism"
Returns the name of the organism in use, if there is one.
.PP
To set this value, use set_organism.
.SS "codontable"
.IX Subsection "codontable"
Returns the codon table in use, if there is one.
.PP
The codon table is a hash reference where the keys are upper case nucleotides
and the values are upper case single letter amino acids.
.PP
.Vb 2
\&    my $codon_t = $GD\->codontable();
\&    $codon_t\->{"ATG"} eq "M" || die;
.Ve
.PP
To set this value, use set_codontable.
.SS "reversecodontable"
.IX Subsection "reversecodontable"
Returns the reverse codon table in use, if there is one.
.PP
The reverse codon table is a hash reference where the keys are upper case single
letter amino acids and the values are upper case nucleotides.
.PP
.Vb 2
\&    my $revcodon_t = $GD\->reversecodontable();
\&    $revcodon_t\->{"M"} eq "ATG" || die;
.Ve
.PP
This value is set automatically when set_codontable is run.
.SS "rscutable"
.IX Subsection "rscutable"
Returns the \s-1RSCU\s0 table in use, if there is one.
.PP
The \s-1RSCU\s0 codon table is a hash reference where the keys are upper case
nucleotides and the values are floats.
.PP
.Vb 2
\&    my $rscu_t = $GD\->rscutable();
\&    $rscu_t\->{"ATG"} eq 1.00 || die;
.Ve
.PP
To set this value, use set_rscu_table.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "melt"
.IX Subsection "melt"
.Vb 1
\&    my $Tm = $GD\->melt(\-sequence => $myseq);
.Ve
.PP
The \-sequence argument is required.
.PP
Returns the melting temperature of a \s-1DNA\s0 sequence.
.PP
You can set the salt and \s-1DNA\s0 concentrations with the \-salt and \-concentration
arguments; they are 50mm (.05) and 100 pm (.0000001) respectively.
.PP
You can pass either a string variable, a Bio::Seq object, or a Bio::SeqFeatureI
object to be analyzed with the \-sequence flag.
.PP
There are four different formulae to choose from. If you wish to use the nearest
neighbor method, use the \-nearest_neighbor flag. Otherwise the appropriate
formula will be determined by the length of your \-sequence argument.
.PP
For sequences under 14 base pairs:
  Tm = (4 * #GC) + (2 * #AT).
.PP
For sequences between 14 and 50 base pairs:
  Tm = 100.5 + (41 * #GC / length) \- (820 / length) + 16.6 * log10(salt)
.PP
For sequences over 50 base pairs:
  Tm = 81.5 + (41 * #GC / length) \- (500 / length) + 16.6 * log10(salt) \- .62;
.SS "complement"
.IX Subsection "complement"
.Vb 1
\&    $my_seq = "AATTCG";
\&    
\&    my $complemented_seq = $GD\->complement($my_seq);
\&    $complemented_seq eq "TTAAGC" || die;
\&    
\&    my $reverse_complemented_seq = $GD\->complement($my_seq, 1);
\&    $reverse_complemented_seq eq "CGAATT" || die;
\&    
\&    #clean
\&    my $complemented_seq = $GD\->complement(\-sequence => $my_seq);
\&    $complemented_seq eq "TTAAGC" || die;
\&    
\&    my $reverse_complemented_seq = $GD\->complement(\-sequence => $my_seq,
\&                                                   \-reverse => 1);
\&    $reverse_complemented_seq eq "CGAATT" || die;
.Ve
.PP
The \-sequence argument is required.
.PP
Complements or reverse complements a \s-1DNA\s0 sequence.
.PP
You can pass either a string variable, a Bio::Seq object, or a Bio::SeqFeatureI
object to be processed.
.PP
If you also pass along a true statement, the sequence will be reversed and
complemented.
.SS "count"
.IX Subsection "count"
.Vb 7
\&    $my_seq = "AATTCG";
\&    my $count = $GD\->count($my_seq);
\&    $count\->{C} == 1 || die;
\&    $count\->{G} == 1 || die;
\&    $count\->{A} == 2 || die;
\&    $count\->{GCp} == 33.3 || die;
\&    $count\->{ATp} == 66.7 || die;
\&    
\&    #clean
\&    my $count = $GD\->count(\-sequence => $my_seq);
.Ve
.PP
You must pass either a string variable, a Bio::Seq object, or a Bio::SeqFeatureI
object.
.PP
the count function counts the bases in a \s-1DNA\s0 sequence and returns a hash
reference where each base (including the ambiguous bases) are keys and the
values are the number of times they appear in the sequence. There are also the
special values GCp and ATp for \s-1GC\s0 and \s-1AT\s0 percentage.
.SS "regex_nt"
.IX Subsection "regex_nt"
.Vb 3
\&    my $my_seq = "ABC";
\&    my $regex = $GD\->regex_nt(\-sequence => $my_seq);
\&    # $regex is qr/A[CGT]C/;
\&    
\&    my $regarr = $GD\->regex_nt(\-sequence => $my_seq \-\-reverse_complement => 1);
\&    # $regarr is [qr/A[CGT]C/, qr/G[ACG]T/]
.Ve
.PP
You must pass either a string variable, a Bio::Seq object, or a Bio::SeqFeatureI
object to be processed with the \-sequence flag.
.PP
regex_nt creates a compiled regular expression or a set of them that can be used
to query large nucleotide sequences for possibly ambiguous subsequences.
.PP
If you want to get regular expressions for both the forward and reverse senses
of the \s-1DNA,\s0 use the \-reverse_complement flag and expect a reference to an array
of compiled regexes.
.SS "regex_aa"
.IX Subsection "regex_aa"
.Vb 3
\&    my $my_pep = "AEQ*";
\&    my $regex = $GD\->regex_aa(\-sequence => $my_pep);
\&    $regex == qr/AEQ[\e*]/ || die;
.Ve
.PP
Creates a compiled regular expression or a set of them that can be used to query
large amino acid sequences for smaller subsequences.
.PP
You can pass either a string variable, a Bio::Seq object, or a Bio::SeqFeatureI
object to be processed with the \-sequence flag.
.SS "sequence_is_ambiguous"
.IX Subsection "sequence_is_ambiguous"
.Vb 3
\&    my $my_seq = "ABC";
\&    my $flag = $GD\->sequence_is_ambiguous($my_seq);
\&    $flag == 1 || die;
\&    
\&    $my_seq = "ATC";
\&    $flag = $GD\->sequence_is_ambiguous($my_seq);
\&    $flag == 0 || die;
.Ve
.PP
Checks to see if a \s-1DNA\s0 sequence contains ambiguous bases (\s-1RYMKWSBDHVN\s0) and
returns true if it does.
.PP
You can pass either a string variable, a Bio::Seq object, or a Bio::SeqFeatureI
object to be processed.
.SS "ambiguous_translation"
.IX Subsection "ambiguous_translation"
.Vb 3
\&    my $my_seq = "ABC";
\&    my @peps = $GD\->ambiguous_translation(\-sequence => $my_seq, \-frame => 1);
\&    # @peps is qw(I T C)
.Ve
.PP
You must pass a string variable, a Bio::Seq object, or a Bio::SeqFeatureI object
to be processed.
.PP
Translates a nucleotide sequence that may have ambiguous bases and returns an
array of possible peptides.
.PP
The frame argument may be 1, 2, 3, \-1, \-2, or \-3.
It may also be t (three, 1, 2, 3), or s (six, 1, 2, 3, \-1, \-2, \-3).
It defaults to 1.
.SS "ambiguous_transcription"
.IX Subsection "ambiguous_transcription"
.Vb 3
\&    my $my_seq = "ABC";
\&    my $seqs = $GD\->ambiguous_transcription($my_seq);
\&    # $seqs is [qw(ACC AGC ATC)]
.Ve
.PP
Deambiguates a nucleotide sequence that may have ambiguous bases and returns a
reference to a sorted array of possible unambiguous sequences.
.PP
You can pass either a string variable, a Bio::Seq object, or a Bio::SeqFeatureI
object to be processed.
.SS "positions"
.IX Subsection "positions"
.Vb 2
\&    my $seq = "TGCTGACTGCAGTCAGTACACTACGTACGTGCATGAC";
\&    my $seek = "CWC";
\&    
\&    my $positions = $GD\->positions(\-sequence => $seq,
\&                                   \-query => $seek);
\&    # $positions is {18 => "CAC"}
\&
\&    $positions = $GD\->positions(\-sequence => $seq,
\&                                \-query => $seek,
\&                                \-reverse_complement => 1);
\&    # $positions is {18 => "CAC", 28 => "GTG"}
.Ve
.PP
Finds and returns all the positions and sequences of a potentially ambiguous
subsequence in a larger sequence. The reverse_complement flag is off by default.
.PP
You can pass either string variables, Bio::Seq objects, or Bio::SeqFeatureI
objects as the sequence and query arguments; additionally you may pass a
RestrictionEnzyme object as the query
argument.
.SS "set_codontable"
.IX Subsection "set_codontable"
.Vb 2
\&    # load a codon table from the GeneDesign configuration directory
\&    $GD\->set_codontable(\-organism_name => "yeast");
\&    
\&    # load a codon table from an arbitrary path and catch it in a variable
\&    my $codon_t = $GD\->set_codontable(\-organism_name => "custom",
\&                                      \-table_path => "/path/to/table.ct");
.Ve
.PP
The \-organism_name argument is required.
.PP
This function loads, sets, and returns a codon definition table. After it is run
the accessor codontable will return the hash reference that
represents the codon table.
.PP
If no path is provided, the configuration directory /codon_tables is checked for
tables that match the provided organism name. If there is no table in that
directory, a warning will appear and the standard codon table will be
used.
.PP
Any codon table that is missing a definition for a codon will cause a warning to
be issued. The table format for codon tables is
.PP
.Vb 5
\&    # Standard genetic code
\&    {TTT} = F
\&    {TTC} = F
\&    {TTA} = L
\&    ...
.Ve
.PP
See \s-1NCBI\s0's table <http://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi#SG1>
.SS "set_rscutable"
.IX Subsection "set_rscutable"
.Vb 2
\&    # load a RSCU table from the GeneDesign configuration directory
\&    $GD\->set_rscutable(\-organism_name => "yeast");
\&    
\&    # load an RSCU table from an arbitrary path and catch it in a variable
\&    my $rscu_t = $GD\->set_rscutable(\-organism_name => "custom",
\&                                    \-table_path => "/path/to/table.rscu");
.Ve
.PP
The \-organism_name argument is required.
.PP
This function loads, sets, and returns an \s-1RSCU\s0 table. After it is run
the accessor rscutable will return the hash reference that
represents the \s-1RSCU\s0 table.
.PP
If no path is provided, the configuration directory /codon_tables is checked for
tables that match the provided organism name. If there is no table in that
directory, a warning will appear and the flat \s-1RSCU\s0 table will be used.
.PP
Any \s-1RSCU\s0 table that is missing a definition for a codon will cause a warning to
be issued. The table format for \s-1RSCU\s0 tables is
.PP
.Vb 6
\&    # Saccharomyces cerevisiae (Highly expressed genes)
\&    # Nucleic Acids Res 16, 8207\-8211 (1988)
\&    {TTT} = 0.19
\&    {TTC} = 1.81
\&    {TTA} = 0.49
\&    ...
.Ve
.PP
See Sharp et al. 1986 <http://www.ncbi.nlm.nih.gov/pubmed/3526280>.
.SS "set_organism"
.IX Subsection "set_organism"
.Vb 2
\&    # load both codon tables and RSCU tables simultaneously
\&    $GD\->set_organism(\-organism_name => "yeast");
\&    
\&    # with arguments
\&    $GD\->set_organism(\-organism_name => "custom",
\&                      \-table_path => "/path/to/table.ct",
\&                      \-rscu_path => "/path/to/table.rscu");
.Ve
.PP
The \-organism_name argument is required.
.PP
This function is just a shortcut; it runs \*(L"set_codontable\*(R" in set_codontable and
\&\*(L"set_rscutable\*(R" in set_rscutable. See those functions for details.
.SS "codon_count"
.IX Subsection "codon_count"
.Vb 2
\&    # count the codons in a list of sequences
\&    my $tally = $GD\->codon_count(\-input => \e@sequences);
\&    
\&    # add a gene to an existing codon count
\&    $tally = $GD\->codon_count(\-input => $sequence,
\&                              \-count => $tally);
\&                              
\&    # add a list of Bio::Seq objects to an existing codon count
\&    $tally = $GD\->codon_count(\-input => \e@seqobjects,
\&                              \-count => $tally);
.Ve
.PP
The \-input argument is required and will take a string variable, a Bio::Seq
object, a Bio::SeqFeatureI object, or a reference to an array full of any
combination of those things.
.PP
The codon_count function takes a set of sequences and counts how often each
codon appears in them. It returns a hash reference where the keys are upper case
nucleotide codons and the values are integers. If you pass a hash reference
containing codon counts with the \-count argument, new counts will be added to
the old values.
.PP
This function will warn you if non nucleotide codons are found.
.PP
\&\s-1TODO:\s0 what about ambiguous codons?
.SS "generate_RSCU_table"
.IX Subsection "generate_RSCU_table"
.Vb 1
\&    my $rscu_t = $GD\->generate_RSCU_table(\-sequences => \e@list_of_sequences);
.Ve
.PP
The \-sequences argument is required and will take a string variable, a Bio::Seq
object, a Bio::SeqFeatureI object, or a reference to an array full of any
combination of those things.
.PP
The generate_RSCU_table function takes a set of sequences, counts how often each
codon appears, and returns an \s-1RSCU\s0 table as a hash reference where the keys are
upper case nucleotide codons and the values are floats.
.PP
See Sharp et al. 1986 <http://www.ncbi.nlm.nih.gov/pubmed/3526280>.
.SS "generate_codon_report"
.IX Subsection "generate_codon_report"
.Vb 1
\&  my $report = $GD\->generate_codon_report(\-sequences => \e@list_of_sequences);
.Ve
.PP
The report will have the format
.PP
.Vb 4
\&  TTT (F) 12800 0.74
\&  TTC (F) 21837 1.26
\&  TTA (L)  4859 0.31
\&  TTG (L) 18806 1.22
.Ve
.PP
where the first column in each group is the codon, the second column is the one
letter amino acid abbreviation in parentheses, the third column is the number of
times that codon has been seen, and the fourth column is the \s-1RSCU\s0 value for that
codon.
.PP
This report comes in a 4x4 layout, as would a standard genetic code table in a
textbook.
.PP
\&\s-1NO TEST\s0
.SS "generate_RSCU_file"
.IX Subsection "generate_RSCU_file"
.Vb 7
\&  my $contents = $GD\->generate_RSCU_file(
\&    \-sequences => \e@seqs,
\&    \-comments => ["Got these codons from mice"]
\&  );
\&  open (my $OUT, \*(Aq>\*(Aq, \*(Aq/path/to/cods\*(Aq) || die "can\*(Aqt write to /path/to/cods";
\&  print $OUT $contents;
\&  close $OUT;
.Ve
.PP
This function generates a string that can be written to file to serve as a
GeneDesign \s-1RSCU\s0 table. Provide a set of sequences and an optional array
reference of comments to prepend to the file.
.PP
The file will have the format
  # Comment 1
  # ...
  # Comment n
  {\s-1TTT\s0} = 0.19
  {\s-1TTC\s0} = 1.81
  ...
.PP
\&\s-1NO TEST\s0
.SS "list_enzyme_sets"
.IX Subsection "list_enzyme_sets"
.Vb 2
\&  my @available_enzlists = $GD\->list_enzyme_sets();
\&  # @available_enzlists == (\*(Aqstandard_and_IIB\*(Aq, \*(Aqblunts\*(Aq, \*(AqIIB\*(Aq, \*(Aqnonpal\*(Aq, ...)
.Ve
.PP
Returns an array containing the names of every restriction enzyme recognition
list GeneDesign knows about.
.SS "set_restriction_enzymes"
.IX Subsection "set_restriction_enzymes"
.Vb 1
\&  $GD\->set_restriction_enzymes(\-enzyme_set => \*(Aqblunts\*(Aq);
.Ve
.PP
or
.PP
.Vb 1
\&  $GD\->set_restriction_enzymes(\-list_path => \*(Aq/path/to/enzyme_file\*(Aq);
.Ve
.PP
or even
.PP
.Vb 4
\&  $GD\->set_restriction_enzymes(
\&    \-list_path => \*(Aq/path/to/enzyme_file\*(Aq,
\&    \-enzyme_set => \*(Aqcustom_enzymes\*(Aq
\&  );
.Ve
.PP
All will return a hash structure full of restriction enzymes.
.PP
Tell GeneDesign which set of restriction enzymes to use. If you provide only a
set name with the \-enzyme_set flag, GeneDesign will check its config path for a
matching file. Otherwise you must provide a path to a file (and optionally a
name for the set).
.SS "remove_from_enzyme_set"
.IX Subsection "remove_from_enzyme_set"
Removes a subset of enzymes from an enzyme list. This only happens in memory, no
files will be altered. The argument is an array reference of enzyme names.
.PP
.Vb 2
\&  $GD\->set_restriction_enzymes(\-enzyme_set => \*(Aqblunts\*(Aq);
\&  $GD\->remove_from_enzyme_set(\-enzymes => [\*(AqSmaI\*(Aq, \*(AqMlyI\*(Aq]);
.Ve
.PP
\&\s-1NO TEST\s0
.SS "add_to_enzyme_set"
.IX Subsection "add_to_enzyme_set"
Adds a subset of enzymes to an enzyme list. This only happens in memory, no
files will be altered. The argument is an array reference of RestrictionEnzyme
objects.
.PP
.Vb 2
\&  #Grab all known enzymes
\&  my $allenz = $GD\->set_restriction_enzymes(\-enzyme_set => \*(Aqstandard_and_IIB\*(Aq);
\&
\&  #Pull out a few
\&  my @keepers = ($allenz\->{\*(AqBmrI\*(Aq}, $allenz\->{\*(AqHphI\*(Aq});
\&
\&  #Give GeneDesign the enzyme set you want
\&  $GD\->set_restriction_enzymes(\-enzyme_set => \*(Aqblunts\*(Aq);
\&
\&  #Add the few enzymes it didn\*(Aqt have before
\&  $GD\->add_to_enzyme_set(\-enzymes => \e@keepers);
.Ve
.PP
\&\s-1NO TEST\s0
.SS "restriction_status"
.IX Subsection "restriction_status"
.SS "build_prefix_tree"
.IX Subsection "build_prefix_tree"
Take an array reference of nucleotide sequences (they can be strings, Bio::Seq
objects, or Bio::GeneDesign::RestrictionEnzyme objects) and create a suffix
tree. If you add the peptide flag, the sequences will be ambiguously translated
before they are added to the suffix tree. Otherwise they will be ambiguously
transcribed. It will add the reverse complement of any non peptide sequence as
long as the reverse complement is different.
.PP
.Vb 1
\&    my $tree = $GD\->build_prefix_tree(\-input => [\*(AqGGATCC\*(Aq]);
\&    
\&    my $ptree = $GD\->build_prefix_tree(
\&      \-input => [\*(AqGGCCNNNNNGGCC\*(Aq],
\&      \-peptide => 1
\&    );
.Ve
.SS "search_prefix_tree"
.IX Subsection "search_prefix_tree"
Takes a suffix tree and a sequence and searches for results, which are returned
as in the Bio::GeneDesign::PrefixTree documentation.
.PP
.Vb 1
\&  my $hits = $GD\->search_prefix_tree(\-tree => $ptree, \-sequence => $mygeneseq);
\&  
\&  # @$hits = ([\*(AqBamHI\*(Aq, 4, \*(AqGGATCC\*(Aq, \*(Aqi hope this didn\*(Aqt pop up\*(Aq],
\&  #          [\*(AqOhnoI\*(Aq, 21, \*(AqGGCCC\*(Aq, \*(AqI hope these pop up\*(Aq],
\&  #          [\*(AqWoopsII\*(Aq, 21, \*(AqGGCCC\*(Aq, \*(AqI hope these pop up\*(Aq]
\&  #);
.Ve
.SS "pattern_aligner"
.IX Subsection "pattern_aligner"
.SS "pattern_adder"
.IX Subsection "pattern_adder"
.SS "codon_change_type"
.IX Subsection "codon_change_type"
.SS "translate"
.IX Subsection "translate"
.SS "reverse_translate"
.IX Subsection "reverse_translate"
.SS "codon_juggle"
.IX Subsection "codon_juggle"
.SS "subtract_sequence"
.IX Subsection "subtract_sequence"
.SS "repeat_smash"
.IX Subsection "repeat_smash"
.SS "make_amplification_primers"
.IX Subsection "make_amplification_primers"
\&\s-1NO TEST\s0
.SS "contains_homopolymer"
.IX Subsection "contains_homopolymer"
Returns 1 if the sequence contains a homopolymer of the provided length (default
is 5bp) and 0 else
.SS "filter_homopolymers"
.IX Subsection "filter_homopolymers"
.SS "search_vmatch"
.IX Subsection "search_vmatch"
.SS "filter_blast"
.IX Subsection "filter_blast"
.SS "carve_building_blocks"
.IX Subsection "carve_building_blocks"
\&\s-1NO TEST\s0
.SS "chop_oligos"
.IX Subsection "chop_oligos"
\&\s-1NO TEST\s0
.SS "make_graph"
.IX Subsection "make_graph"
.SS "make_dotplot"
.IX Subsection "make_dotplot"
.SS "import_seqs"
.IX Subsection "import_seqs"
\&\s-1NO TEST\s0
.SS "export_seqs"
.IX Subsection "export_seqs"
\&\s-1NO TEST\s0
.SS "random_dna"
.IX Subsection "random_dna"
.SS "replace_ambiguous_bases"
.IX Subsection "replace_ambiguous_bases"
.SH "PLEASANTRIES"
.IX Header "PLEASANTRIES"
.SS "pad"
.IX Subsection "pad"
.Vb 3
\&    my $name = 5;
\&    my $nice = $GD\->pad($name, 3);
\&    $nice == "005" || die;
\&
\&    $name = "oligo";
\&    $nice = $GD\->pad($name, 7, "_");
\&    $nice == "_\|_oligo" || die;
.Ve
.PP
Pads an integer with leading zeroes (by default) or any provided set of
characters. This is useful both to make reports pretty and to standardize the
length of designations.
.SS "attitude"
.IX Subsection "attitude"
.Vb 1
\&    my $adverb = $GD\->attitude();
.Ve
.PP
Ask GeneDesign how it handled your request.
.SS "endslash"
.IX Subsection "endslash"
.SS "_stripdown"
.IX Subsection "_stripdown"
.SS "_checkref"
.IX Subsection "_checkref"
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2013, GeneDesign developers
All rights reserved.
.PP
Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:
.PP
* Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.
.PP
* Redistributions in binary form must reproduce the above copyright notice, this
list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.
.PP
* The names of Johns Hopkins, the Joint Genome Institute, the Lawrence Berkeley
National Laboratory, the Department of Energy, and the GeneDesign developers may
not be used to endorse or promote products derived from this software without
specific prior written permission.
.PP
\&\s-1THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \*(L"AS IS\*(R" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE DEVELOPERS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES \s0(\s-1INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES\s0; \s-1LOSS OF USE, DATA, OR
PROFITS\s0; \s-1OR BUSINESS INTERRUPTION\s0) \s-1HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \s0(\s-1INCLUDING NEGLIGENCE
OR OTHERWISE\s0) \s-1ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\s0
